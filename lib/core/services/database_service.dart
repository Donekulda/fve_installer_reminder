import 'package:mysql1/mysql1.dart';
import '../../data/models/user.dart';
import '../../data/models/required_image.dart';
import '../../data/models/fve_installation.dart';
import '../../data/models/saved_image.dart';
import '../config/config_service.dart';
import '../utils/logger.dart';

/// Service class for handling all database operations.
/// Manages connections and provides methods for CRUD operations on all entities.
class DatabaseService {
  /// MySQL connection instance
  late MySqlConnection _connection;

  /// Flag indicating if the database is connected
  bool _isConnected = false;

  /// Logger instance for database operations
  final _logger = AppLogger('DatabaseService');

  /// Establishes a connection to the database using credentials from ConfigService.
  /// Throws an exception if connection fails.
  Future<void> connect() async {
    try {
      _logger.info('Attempting to connect to database...');
      final credentials = await ConfigService.getDatabaseCredentials();
      final settings = ConnectionSettings(
        host: credentials.host,
        port: credentials.port,
        user: credentials.user,
        password: credentials.password,
        db: credentials.database,
      );
      _connection = await MySqlConnection.connect(settings);
      _isConnected = true;
      _logger.info('Successfully connected to database');
    } catch (e) {
      _isConnected = false;
      _logger.error('Failed to connect to database', e);
      rethrow;
    }
  }

  // User operations
  /// Authenticates a user with the given username and password.
  /// Returns the user if authentication is successful and the account is active.
  /// Returns null if authentication fails or the account is inactive.
  Future<User?> authenticateUser(String username, String password) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Authenticating user: $username');
      _logger.debug('Password length: ${password.length}');
      _logger.debug('Executing authentication query');
      final results = await _connection.query(
        'SELECT * FROM users WHERE nick = ? AND pass = ? AND active = 1',
        [username, password],
      );

      _logger.debug('Query returned ${results.length} results');
      if (results.isEmpty) {
        _logger.info('Authentication failed for user: $username');
        return null;
      }
      _logger.info('User authenticated successfully: $username');
      return User.fromJson(results.first.fields);
    } catch (e) {
      _logger.error('Error during user authentication', e);
      rethrow;
    }
  }

  /// Retrieves all users from the database.
  /// Returns a list of all users, including inactive ones.
  Future<List<User>> getAllUsers() async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving all users');
      final results = await _connection.query('SELECT * FROM users');
      _logger.info('Retrieved ${results.length} users');
      return results.map((row) => User.fromJson(row.fields)).toList();
    } catch (e) {
      _logger.error('Error retrieving all users', e);
      rethrow;
    }
  }

  /// Retrieves a user by their ID.
  /// Returns null if no user is found with the given ID.
  Future<User?> getUserById(int id) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving user with ID: $id');
      final results = await _connection.query(
        'SELECT * FROM users WHERE id = ?',
        [id],
      );

      if (results.isEmpty) {
        _logger.info('No user found with ID: $id');
        return null;
      }
      _logger.info('User retrieved successfully: ID $id');
      return User.fromJson(results.first.fields);
    } catch (e) {
      _logger.error('Error retrieving user by ID', e);
      rethrow;
    }
  }

  /// Adds a new user to the database.
  /// The user's ID will be automatically generated by the database.
  Future<void> addUser(User user) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Adding new user: ${user.username}');
      await _connection.query(
        'INSERT INTO users (nick, pass, fullname, privileges, active) VALUES (?, ?, ?, ?, ?)',
        [
          user.username,
          user.password,
          user.fullname,
          user.privileges,
          user.active ? 1 : 0,
        ],
      );
      _logger.info('User added successfully: ${user.username}');
    } catch (e) {
      _logger.error('Error adding new user', e);
      rethrow;
    }
  }

  /// Updates an existing user in the database.
  /// All fields will be updated with the values from the provided user object.
  Future<void> updateUser(User user) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Updating user: ${user.username}');
      await _connection.query(
        'UPDATE users SET nick = ?, pass = ?, fullname = ?, privileges = ?, active = ? WHERE id = ?',
        [
          user.username,
          user.password,
          user.fullname,
          user.privileges,
          user.active ? 1 : 0,
          user.id,
        ],
      );
      _logger.info('User updated successfully: ${user.username}');
    } catch (e) {
      _logger.error('Error updating user', e);
      rethrow;
    }
  }

  /// Deactivates a user by setting their active status to 0.
  /// The user will not be able to log in after deactivation.
  Future<void> deactivateUser(int userId) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Deactivating user with ID: $userId');
      await _connection.query('UPDATE users SET active = 0 WHERE id = ?', [
        userId,
      ]);
      _logger.info('User deactivated successfully: ID $userId');
    } catch (e) {
      _logger.error('Error deactivating user', e);
      rethrow;
    }
  }

  /// Activates a user by setting their active status to 1.
  /// The user will be able to log in after activation.
  Future<void> activateUser(int userId) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Activating user with ID: $userId');
      await _connection.query('UPDATE users SET active = 1 WHERE id = ?', [
        userId,
      ]);
      _logger.info('User activated successfully: ID $userId');
    } catch (e) {
      _logger.error('Error activating user', e);
      rethrow;
    }
  }

  // FVE Installation operations
  /// Retrieves an FVE installation by its ID.
  /// Returns null if no installation is found with the given ID.
  Future<FVEInstallation?> getFVEInstallationById(int id) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving FVE installation with ID: $id');
      final results = await _connection.query(
        'SELECT * FROM fveInstalations WHERE id = ?',
        [id],
      );

      if (results.isEmpty) {
        _logger.info('No FVE installation found with ID: $id');
        return null;
      }
      _logger.info('FVE installation retrieved successfully: ID $id');
      return FVEInstallation.fromJson(results.first.fields);
    } catch (e) {
      _logger.error('Error retrieving FVE installation by ID', e);
      rethrow;
    }
  }

  /// Retrieves all FVE installations assigned to a specific user.
  /// Returns a list of installations where the user is responsible.
  Future<List<FVEInstallation>> getInstallationsByUserId(int userId) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving FVE installations for user ID: $userId');
      final results = await _connection.query(
        'SELECT * FROM fveInstalations WHERE users_id = ?',
        [userId],
      );
      _logger.info(
        'Retrieved ${results.length} FVE installations for user ID: $userId',
      );
      return results
          .map((row) => FVEInstallation.fromJson(row.fields))
          .toList();
    } catch (e) {
      _logger.error('Error retrieving FVE installations by user ID', e);
      rethrow;
    }
  }

  /// Retrieves all FVE installations from the database.
  /// Returns a list of all installations, regardless of assigned user.
  Future<List<FVEInstallation>> getAllInstallations() async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving all FVE installations');
      final results = await _connection.query('SELECT * FROM fveInstalations');
      _logger.info('Retrieved ${results.length} FVE installations');
      return results
          .map((row) => FVEInstallation.fromJson(row.fields))
          .toList();
    } catch (e) {
      _logger.error('Error retrieving all FVE installations', e);
      rethrow;
    }
  }

  /// Adds a new FVE installation to the database.
  /// The installation's ID will be automatically generated by the database.
  Future<void> addFVEInstallation(FVEInstallation installation) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Adding new FVE installation: ${installation.name}');
      await _connection.query(
        'INSERT INTO fveInstalations (name, region, address, users_id) VALUES (?, ?, ?, ?)',
        [
          installation.name,
          installation.region,
          installation.address,
          installation.userId,
        ],
      );
      _logger.info('FVE installation added successfully: ${installation.name}');
    } catch (e) {
      _logger.error('Error adding new FVE installation', e);
      rethrow;
    }
  }

  /// Updates an existing FVE installation in the database.
  /// All fields will be updated with the values from the provided installation object.
  Future<void> updateFVEInstallation(FVEInstallation installation) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Updating FVE installation: ${installation.name}');
      await _connection.query(
        'UPDATE fveInstalations SET name = ?, region = ?, adresa = ?, users_id = ? WHERE id = ?',
        [
          installation.name,
          installation.region,
          installation.address,
          installation.userId,
          installation.id,
        ],
      );
      _logger.info(
        'FVE installation updated successfully: ${installation.name}',
      );
    } catch (e) {
      _logger.error('Error updating FVE installation', e);
      rethrow;
    }
  }

  // Required Images operations
  /// Retrieves a required image type by its ID.
  /// Returns null if no required image type is found with the given ID.
  Future<RequiredImage?> getRequiredImageById(int id) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving required image with ID: $id');
      final results = await _connection.query(
        'SELECT * FROM requiredImages WHERE id = ?',
        [id],
      );

      if (results.isEmpty) {
        _logger.info('No required image found with ID: $id');
        return null;
      }
      _logger.info('Required image retrieved successfully: ID $id');
      return RequiredImage.fromJson(results.first.fields);
    } catch (e) {
      _logger.error('Error retrieving required image by ID', e);
      rethrow;
    }
  }

  /// Retrieves all required image types from the database.
  /// Returns a list of all required image types.
  Future<List<RequiredImage>> getAllRequiredImages() async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving all required images');
      final results = await _connection.query('SELECT * FROM requiredImages');
      _logger.info('Retrieved ${results.length} required images');
      return results.map((row) => RequiredImage.fromJson(row.fields)).toList();
    } catch (e) {
      _logger.error('Error retrieving all required images', e);
      rethrow;
    }
  }

  /// Adds a new required image type to the database.
  /// The required image type's ID will be automatically generated by the database.
  Future<void> addRequiredImage(RequiredImage image) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Adding new required image: ${image.name}');
      await _connection.query(
        'INSERT INTO requiredImages (name, min_images, description) VALUES (?, ?, ?)',
        [image.name, image.minImages, image.description],
      );
      _logger.info('Required image added successfully: ${image.name}');
    } catch (e) {
      _logger.error('Error adding new required image', e);
      rethrow;
    }
  }

  /// Updates an existing required image type in the database.
  /// All fields will be updated with the values from the provided required image type object.
  Future<void> updateRequiredImage(RequiredImage image) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Updating required image: ${image.name}');
      await _connection.query(
        'UPDATE requiredImages SET name = ?, min_images = ?, description = ? WHERE id = ?',
        [image.name, image.minImages, image.description, image.id],
      );
      _logger.info('Required image updated successfully: ${image.name}');
    } catch (e) {
      _logger.error('Error updating required image', e);
      rethrow;
    }
  }

  // Saved Images operations
  /// Retrieves a saved image by its ID.
  /// Returns null if no saved image is found with the given ID.
  Future<SavedImage?> getSavedImageById(int id) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving saved image with ID: $id');
      final results = await _connection.query(
        'SELECT * FROM savedImages WHERE id = ?',
        [id],
      );

      if (results.isEmpty) {
        _logger.info('No saved image found with ID: $id');
        return null;
      }
      _logger.info('Saved image retrieved successfully: ID $id');
      return SavedImage.fromJson(results.first.fields);
    } catch (e) {
      _logger.error('Error retrieving saved image by ID', e);
      rethrow;
    }
  }

  /// Retrieves all saved images for a specific FVE installation.
  /// Returns a list of all images associated with the given installation.
  Future<List<SavedImage>> getSavedImagesByInstallationId(
    int installationId,
  ) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug(
        'Retrieving saved images for installation ID: $installationId',
      );
      final results = await _connection.query(
        'SELECT * FROM savedImages WHERE fveInstalations_id = ?',
        [installationId],
      );
      _logger.info(
        'Retrieved ${results.length} saved images for installation ID: $installationId',
      );
      return results.map((row) => SavedImage.fromJson(row.fields)).toList();
    } catch (e) {
      _logger.error('Error retrieving saved images by installation ID', e);
      rethrow;
    }
  }

  /// Retrieves all saved images of a specific required image type.
  /// Returns a list of all images of the given required image type.
  Future<List<SavedImage>> getSavedImagesByRequiredImageId(
    int requiredImageId,
  ) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug(
        'Retrieving saved images for required image ID: $requiredImageId',
      );
      final results = await _connection.query(
        'SELECT * FROM savedImages WHERE requiredImages_id = ?',
        [requiredImageId],
      );
      _logger.info(
        'Retrieved ${results.length} saved images for required image ID: $requiredImageId',
      );
      return results.map((row) => SavedImage.fromJson(row.fields)).toList();
    } catch (e) {
      _logger.error('Error retrieving saved images by required image ID', e);
      rethrow;
    }
  }

  /// Saves a new image to the database.
  /// The image's ID will be automatically generated by the database.
  /// The user ID is required to track who added the image.
  Future<void> saveImage(SavedImage image) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Saving new image: ${image.name}');
      await _connection.query(
        'INSERT INTO savedImages (fveInstalations_id, requiredImages_id, location, timeAdded, name, HASH, active, users_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
        [
          image.fveInstallationId,
          image.requiredImageId,
          image.location,
          image.timeAdded?.toIso8601String(),
          image.name,
          image.hash,
          image.active ? 1 : 0,
          image.userId,
        ],
      );
      _logger.info('Image saved successfully: ${image.name}');
    } catch (e) {
      _logger.error('Error saving new image', e);
      rethrow;
    }
  }

  /// Updates an existing saved image in the database.
  /// All fields will be updated with the values from the provided saved image object.
  Future<void> updateSavedImage(SavedImage image) async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Updating saved image: ${image.name}');
      await _connection.query(
        'UPDATE savedImages SET location = ?, timeAdded = ?, name = ?, HASH = ?, active = ? WHERE id = ?',
        [
          image.location,
          image.timeAdded?.toIso8601String(),
          image.name,
          image.hash,
          image.active ? 1 : 0,
          image.id,
        ],
      );
      _logger.info('Saved image updated successfully: ${image.name}');
    } catch (e) {
      _logger.error('Error updating saved image', e);
      rethrow;
    }
  }

  /// Retrieves all active images from the database.
  /// Returns a list of all images that are marked as active.
  Future<List<SavedImage>> getActiveImages() async {
    if (!_isConnected) {
      _logger.error('Database not connected');
      throw Exception('Database not connected');
    }

    try {
      _logger.debug('Retrieving all active images');
      final results = await _connection.query(
        'SELECT * FROM savedImages WHERE active = 1',
      );
      _logger.info('Retrieved ${results.length} active images');
      return results.map((row) => SavedImage.fromJson(row.fields)).toList();
    } catch (e) {
      _logger.error('Error retrieving active images', e);
      rethrow;
    }
  }

  /// Closes the database connection.
  /// Should be called when the application is shutting down.
  Future<void> disconnect() async {
    if (_isConnected) {
      try {
        _logger.info('Disconnecting from database');
        await _connection.close();
        _isConnected = false;
        _logger.info('Successfully disconnected from database');
      } catch (e) {
        _logger.error('Error disconnecting from database', e);
        rethrow;
      }
    }
  }
}
