import 'package:mysql1/mysql1.dart';
import '../../data/models/user.dart';
import '../../data/models/required_image.dart';
import '../../data/models/fve_installation.dart';
import '../../data/models/saved_image.dart';
import '../config/config_service.dart';

/// Service class for handling all database operations.
/// Manages connections and provides methods for CRUD operations on all entities.
class DatabaseService {
  /// MySQL connection instance
  late MySqlConnection _connection;

  /// Flag indicating if the database is connected
  bool _isConnected = false;

  /// Establishes a connection to the database using credentials from ConfigService.
  /// Throws an exception if connection fails.
  Future<void> connect() async {
    try {
      final credentials = await ConfigService.getDatabaseCredentials();
      final settings = ConnectionSettings(
        host: credentials.host,
        port: credentials.port,
        user: credentials.user,
        password: credentials.password,
        db: credentials.database,
      );
      _connection = await MySqlConnection.connect(settings);
      _isConnected = true;
    } catch (e) {
      _isConnected = false;
      rethrow;
    }
  }

  // User operations
  /// Authenticates a user with the given username and password.
  /// Returns the user if authentication is successful and the account is active.
  /// Returns null if authentication fails or the account is inactive.
  Future<User?> authenticateUser(String username, String password) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM users WHERE nick = ? AND pass = ? AND active = 1',
      [username, password],
    );

    if (results.isEmpty) return null;
    return User.fromJson(results.first.fields);
  }

  /// Retrieves all users from the database.
  /// Returns a list of all users, including inactive ones.
  Future<List<User>> getAllUsers() async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query('SELECT * FROM users');
    return results.map((row) => User.fromJson(row.fields)).toList();
  }

  /// Retrieves a user by their ID.
  /// Returns null if no user is found with the given ID.
  Future<User?> getUserById(int id) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM users WHERE id = ?',
      [id],
    );

    if (results.isEmpty) return null;
    return User.fromJson(results.first.fields);
  }

  /// Adds a new user to the database.
  /// The user's ID will be automatically generated by the database.
  Future<void> addUser(User user) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'INSERT INTO users (nick, pass, fullname, privileges, active) VALUES (?, ?, ?, ?, ?)',
      [
        user.username,
        user.password,
        user.fullname,
        user.privileges,
        user.active ? 1 : 0,
      ],
    );
  }

  /// Updates an existing user in the database.
  /// All fields will be updated with the values from the provided user object.
  Future<void> updateUser(User user) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'UPDATE users SET nick = ?, pass = ?, fullname = ?, privileges = ?, active = ? WHERE id = ?',
      [
        user.username,
        user.password,
        user.fullname,
        user.privileges,
        user.active ? 1 : 0,
        user.id,
      ],
    );
  }

  /// Deactivates a user by setting their active status to 0.
  /// The user will not be able to log in after deactivation.
  Future<void> deactivateUser(int userId) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query('UPDATE users SET active = 0 WHERE id = ?', [
      userId,
    ]);
  }

  /// Activates a user by setting their active status to 1.
  /// The user will be able to log in after activation.
  Future<void> activateUser(int userId) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query('UPDATE users SET active = 1 WHERE id = ?', [
      userId,
    ]);
  }

  // FVE Installation operations
  /// Retrieves an FVE installation by its ID.
  /// Returns null if no installation is found with the given ID.
  Future<FVEInstallation?> getFVEInstallationById(int id) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM fveInstalations WHERE id = ?',
      [id],
    );

    if (results.isEmpty) return null;
    return FVEInstallation.fromJson(results.first.fields);
  }

  /// Retrieves all FVE installations assigned to a specific user.
  /// Returns a list of installations where the user is responsible.
  Future<List<FVEInstallation>> getInstallationsByUserId(int userId) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM fveInstalations WHERE users_id = ?',
      [userId],
    );
    return results.map((row) => FVEInstallation.fromJson(row.fields)).toList();
  }

  /// Retrieves all FVE installations from the database.
  /// Returns a list of all installations, regardless of assigned user.
  Future<List<FVEInstallation>> getAllInstallations() async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query('SELECT * FROM fveInstalations');
    return results.map((row) => FVEInstallation.fromJson(row.fields)).toList();
  }

  /// Adds a new FVE installation to the database.
  /// The installation's ID will be automatically generated by the database.
  Future<void> addFVEInstallation(FVEInstallation installation) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'INSERT INTO fveInstalations (name, region, address, users_id) VALUES (?, ?, ?, ?)',
      [
        installation.name,
        installation.region,
        installation.address,
        installation.userId,
      ],
    );
  }

  /// Updates an existing FVE installation in the database.
  /// All fields will be updated with the values from the provided installation object.
  Future<void> updateFVEInstallation(FVEInstallation installation) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'UPDATE fveInstalations SET name = ?, region = ?, adresa = ?, users_id = ? WHERE id = ?',
      [
        installation.name,
        installation.region,
        installation.address,
        installation.userId,
        installation.id,
      ],
    );
  }

  // Required Images operations
  /// Retrieves a required image type by its ID.
  /// Returns null if no required image type is found with the given ID.
  Future<RequiredImage?> getRequiredImageById(int id) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM requiredImages WHERE id = ?',
      [id],
    );

    if (results.isEmpty) return null;
    return RequiredImage.fromJson(results.first.fields);
  }

  /// Retrieves all required image types from the database.
  /// Returns a list of all required image types.
  Future<List<RequiredImage>> getAllRequiredImages() async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query('SELECT * FROM requiredImages');
    return results.map((row) => RequiredImage.fromJson(row.fields)).toList();
  }

  /// Adds a new required image type to the database.
  /// The required image type's ID will be automatically generated by the database.
  Future<void> addRequiredImage(RequiredImage image) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'INSERT INTO requiredImages (name, min_images, description) VALUES (?, ?, ?)',
      [image.name, image.minImages, image.description],
    );
  }

  /// Updates an existing required image type in the database.
  /// All fields will be updated with the values from the provided required image type object.
  Future<void> updateRequiredImage(RequiredImage image) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'UPDATE requiredImages SET name = ?, min_images = ?, description = ? WHERE id = ?',
      [image.name, image.minImages, image.description, image.id],
    );
  }

  // Saved Images operations
  /// Retrieves a saved image by its ID.
  /// Returns null if no saved image is found with the given ID.
  Future<SavedImage?> getSavedImageById(int id) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM savedImages WHERE id = ?',
      [id],
    );

    if (results.isEmpty) return null;
    return SavedImage.fromJson(results.first.fields);
  }

  /// Retrieves all saved images for a specific FVE installation.
  /// Returns a list of all images associated with the given installation.
  Future<List<SavedImage>> getSavedImagesByInstallationId(
    int installationId,
  ) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM savedImages WHERE fveInstalations_id = ?',
      [installationId],
    );
    return results.map((row) => SavedImage.fromJson(row.fields)).toList();
  }

  /// Retrieves all saved images of a specific required image type.
  /// Returns a list of all images of the given required image type.
  Future<List<SavedImage>> getSavedImagesByRequiredImageId(
    int requiredImageId,
  ) async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM savedImages WHERE requiredImages_id = ?',
      [requiredImageId],
    );
    return results.map((row) => SavedImage.fromJson(row.fields)).toList();
  }

  /// Saves a new image to the database.
  /// The image's ID will be automatically generated by the database.
  /// The user ID is required to track who added the image.
  Future<void> saveImage(SavedImage image) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'INSERT INTO savedImages (fveInstalations_id, requiredImages_id, location, timeAdded, name, HASH, active, users_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
      [
        image.fveInstallationId,
        image.requiredImageId,
        image.location,
        image.timeAdded?.toIso8601String(),
        image.name,
        image.hash,
        image.active ? 1 : 0,
        image.userId,
      ],
    );
  }

  /// Updates an existing saved image in the database.
  /// All fields will be updated with the values from the provided saved image object.
  Future<void> updateSavedImage(SavedImage image) async {
    if (!_isConnected) throw Exception('Database not connected');

    await _connection.query(
      'UPDATE savedImages SET location = ?, timeAdded = ?, name = ?, HASH = ?, active = ? WHERE id = ?',
      [
        image.location,
        image.timeAdded?.toIso8601String(),
        image.name,
        image.hash,
        image.active ? 1 : 0,
        image.id,
      ],
    );
  }

  /// Retrieves all active images from the database.
  /// Returns a list of all images that are marked as active.
  Future<List<SavedImage>> getActiveImages() async {
    if (!_isConnected) throw Exception('Database not connected');

    final results = await _connection.query(
      'SELECT * FROM savedImages WHERE active = 1',
    );
    return results.map((row) => SavedImage.fromJson(row.fields)).toList();
  }

  /// Closes the database connection.
  /// Should be called when the application is shutting down.
  Future<void> disconnect() async {
    if (_isConnected) {
      await _connection.close();
      _isConnected = false;
    }
  }
}
